-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The subset of awesome content tracker Git
--   
--   Please see the README on GitHub at
--   <a>https://github.com/falgon/hmgit#readme</a>
@package hmgit
@version 1.0.0

module HMGit.Development.TH
relativeProjRoot :: FilePath -> Q Exp

module HMGit.Internal.Exceptions
invalidArgument :: String -> IOError
noSuchThing :: String -> FilePath -> IOException
newtype BugException
BugException :: String -> BugException
class MonadThrowable m
fromMonad :: (MonadThrowable m, MonadThrow n, Exception e) => Maybe e -> m ~> n
instance GHC.Show.Show HMGit.Internal.Exceptions.BugException
instance GHC.Exception.Type.Exception e => HMGit.Internal.Exceptions.MonadThrowable (Data.Either.Either e)
instance HMGit.Internal.Exceptions.MonadThrowable GHC.Maybe.Maybe
instance HMGit.Internal.Exceptions.MonadThrowable Data.Functor.Identity.Identity
instance HMGit.Internal.Exceptions.MonadThrowable []
instance (GHC.Exception.Type.Exception e, HMGit.Internal.Exceptions.MonadThrowable m) => HMGit.Internal.Exceptions.MonadThrowable (Control.Monad.Trans.Except.ExceptT e m)
instance HMGit.Internal.Exceptions.MonadThrowable m => HMGit.Internal.Exceptions.MonadThrowable (Control.Monad.Trans.Maybe.MaybeT m)
instance HMGit.Internal.Exceptions.MonadThrowable m => HMGit.Internal.Exceptions.MonadThrowable (Control.Monad.Trans.Identity.IdentityT m)
instance HMGit.Internal.Exceptions.MonadThrowable m => HMGit.Internal.Exceptions.MonadThrowable (Control.Monad.Trans.List.ListT m)
instance (GHC.Exception.Type.Exception e, HMGit.Internal.Exceptions.MonadThrowable m) => HMGit.Internal.Exceptions.MonadThrowable (Control.Monad.Trans.Error.ErrorT e m)
instance GHC.Exception.Type.Exception HMGit.Internal.Exceptions.BugException

module HMGit.Internal.Core.Runner.HMGitConfig
data HMGitConfig
HMGitConfig :: Path Abs Dir -> Int -> HMGitConfig
[hmGitDir] :: HMGitConfig -> Path Abs Dir
[hmGitTreeLimit] :: HMGitConfig -> Int
HMGitConfigInit :: HMGitConfig
hmGitConfig :: (MonadThrow m, MonadIO m) => String -> m HMGitConfig

module HMGit.Internal.Parser.Pathspecs.Glob
transpile :: MonadThrow m => String -> m GlobIR
isLiteral :: GlobIR -> Bool
match :: String -> GlobIR -> Bool
match' :: String -> String -> Bool
instance GHC.Show.Show HMGit.Internal.Parser.Pathspecs.Glob.GlobIRToken

module HMGit.Internal.Utils
strictOne :: (MonadPlus m, MonadThrow m) => [a] -> m a
foldMapM :: (Monad m, Monoid w, Foldable t) => (a -> m w) -> t a -> m w
foldChoice :: (Foldable t, Alternative f) => (a -> f b) -> t a -> f b
foldChoiceM :: (Monad m, Alternative f, Foldable t) => (a -> m (f b)) -> t a -> m (f b)
first3M :: Functor m => (a -> m a') -> (a, b, c) -> m (a', b, c)
makeRelativeEx :: (MonadIO m, MonadThrow m) => FilePath -> FilePath -> m FilePath
(?*>) :: Alternative f => Bool -> f a -> f a
(??) :: Functor f => f (a -> b) -> a -> f b
bothM :: Monad m => (a -> m b) -> (a, a) -> m (b, b)
hexStr :: (MonoFoldable mono, PrintfArg (Element mono)) => mono -> String
instance GHC.Show.Show HMGit.Internal.Utils.DifferentDrives
instance GHC.Exception.Type.Exception HMGit.Internal.Utils.DifferentDrives

module HMGit.Internal.Parser.Core.ByteString
data ParseException
TreeParser :: String -> ParseException
IndexParser :: String -> ParseException
MasterHashParser :: String -> ParseException
runByteStringParser :: (MonadThrow m, Show e, ShowErrorComponent e, Typeable e, VisualStream s, TraversableStream s, Typeable s, Show s, Show (Token s)) => Parsec e s a -> Path b t -> s -> m a
type ByteStringParser = Parsec ParseException ByteString

-- | null
null :: ByteStringParser Word8

-- | M.space is fine but we just want to match 0x20
space :: ByteStringParser ()

-- | decimal
decimal :: Num i => ByteStringParser i

-- | octal
octal :: Num i => ByteStringParser i

-- | Natural transformation from Get to parsec
fromBinaryGetter :: (String -> ParseException) -> Get ~> ByteStringParser

-- | parse relative file path until null
relFile :: ByteStringParser (Path Rel File)
instance GHC.Show.Show HMGit.Internal.Parser.Core.ByteString.ParseException
instance GHC.Classes.Ord HMGit.Internal.Parser.Core.ByteString.ParseException
instance GHC.Classes.Eq HMGit.Internal.Parser.Core.ByteString.ParseException
instance Text.Megaparsec.Error.ShowErrorComponent HMGit.Internal.Parser.Core.ByteString.ParseException
instance GHC.Exception.Type.Exception HMGit.Internal.Parser.Core.ByteString.ParseException

module HMGit.Internal.Parser.Index
data IndexEntry
IndexEntry :: Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> ByteString -> Word16 -> Path Rel File -> IndexEntry

-- | the last time a file's metadata changed, this is stat(2) data
[ieCtimeS] :: IndexEntry -> Word32

-- | nanosecond fractions, this is stat(2) data
[ieCtimeN] :: IndexEntry -> Word32

-- | mtime seconds, the last time a file's data changed, this is stat(2)
--   data
[ieMTimeS] :: IndexEntry -> Word32

-- | mtime nanosecond fractions, this is stat(2) data
[ieMTimeN] :: IndexEntry -> Word32

-- | this is stat(2) data
[ieDev] :: IndexEntry -> Word32

-- | this is stat(2) data
[ieIno] :: IndexEntry -> Word32

-- | mode, split into (high to low bits)
[ieMode] :: IndexEntry -> Word32

-- | this is stat(2) data
[ieUid] :: IndexEntry -> Word32

-- | this is stat(2) data
[ieGid] :: IndexEntry -> Word32

-- | This is the on-disk size from stat(2), truncated to 32-bit.
[ieSize] :: IndexEntry -> Word32

-- | 160-bit SHA-1 for the represented object
[ieSha1] :: IndexEntry -> ByteString

-- | A 16-bit <tt>flags</tt> field split into (high to low bits)
[ieFlags] :: IndexEntry -> Word16
[iePath] :: IndexEntry -> Path Rel File
indexParser :: ByteStringParser [IndexEntry]
putIndex :: Foldable t => t IndexEntry -> Put
instance GHC.Show.Show HMGit.Internal.Parser.Index.IndexHeader
instance GHC.Show.Show HMGit.Internal.Parser.Index.IndexEntry

module HMGit.Internal.Parser.Core

module HMGit.Internal.Parser.Object

-- | The Git object type. Currently, it does not support tags.
data ObjectType

-- | Blob object
Blob :: ObjectType

-- | Commit object
Commit :: ObjectType

-- | Tree object
Tree :: ObjectType

-- | Object binary parser
objectParser :: ByteStringParser (ObjectType, ByteString)

-- | Tree binary parser
treeParser :: Int -> ByteStringParser [(CMode, Path Rel File, String)]
instance GHC.Enum.Enum HMGit.Internal.Parser.Object.ObjectType
instance GHC.Classes.Eq HMGit.Internal.Parser.Object.ObjectType
instance GHC.Show.Show HMGit.Internal.Parser.Object.ObjectType
instance GHC.Read.Read HMGit.Internal.Parser.Object.ObjectType

module HMGit.Internal.Parser
type ByteStringParser = Parsec ParseException ByteString
data ParseException
runByteStringParser :: (MonadThrow m, Show e, ShowErrorComponent e, Typeable e, VisualStream s, TraversableStream s, Typeable s, Show s, Show (Token s)) => Parsec e s a -> Path b t -> s -> m a

-- | The Git object type. Currently, it does not support tags.
data ObjectType

-- | Blob object
Blob :: ObjectType

-- | Commit object
Commit :: ObjectType

-- | Tree object
Tree :: ObjectType

-- | Object binary parser
objectParser :: ByteStringParser (ObjectType, ByteString)

-- | Tree binary parser
treeParser :: Int -> ByteStringParser [(CMode, Path Rel File, String)]
data IndexEntry
IndexEntry :: Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> ByteString -> Word16 -> Path Rel File -> IndexEntry

-- | the last time a file's metadata changed, this is stat(2) data
[ieCtimeS] :: IndexEntry -> Word32

-- | nanosecond fractions, this is stat(2) data
[ieCtimeN] :: IndexEntry -> Word32

-- | mtime seconds, the last time a file's data changed, this is stat(2)
--   data
[ieMTimeS] :: IndexEntry -> Word32

-- | mtime nanosecond fractions, this is stat(2) data
[ieMTimeN] :: IndexEntry -> Word32

-- | this is stat(2) data
[ieDev] :: IndexEntry -> Word32

-- | this is stat(2) data
[ieIno] :: IndexEntry -> Word32

-- | mode, split into (high to low bits)
[ieMode] :: IndexEntry -> Word32

-- | this is stat(2) data
[ieUid] :: IndexEntry -> Word32

-- | this is stat(2) data
[ieGid] :: IndexEntry -> Word32

-- | This is the on-disk size from stat(2), truncated to 32-bit.
[ieSize] :: IndexEntry -> Word32

-- | 160-bit SHA-1 for the represented object
[ieSha1] :: IndexEntry -> ByteString

-- | A 16-bit <tt>flags</tt> field split into (high to low bits)
[ieFlags] :: IndexEntry -> Word16
[iePath] :: IndexEntry -> Path Rel File
indexParser :: ByteStringParser [IndexEntry]
putIndex :: Foldable t => t IndexEntry -> Put

module HMGit.Internal.Core.Runner.API
type HMGitT = ReaderT HMGitConfig

-- | Get an abstract path to the HMGit database directory
hmGitDBPath :: Monad m => HMGitT m (Path Abs Dir)

-- | Get the HMGit database name
hmGitDBName :: Monad m => HMGitT m String

-- | Read refs/heads/master. If it does not exist, look for refs/heads/main
--   as a fallback. The <tt>Nothing</tt> will be returned if neither
--   exists.
hmGitLoadMasterHash :: (MonadIO m, MonadThrow m) => HMGitT m (Maybe String)

-- | Get an abstract path to the HMGit project directory
hmGitRoot :: Monad m => HMGitT m (Path Abs Dir)

-- | Get a loop limit of the tree
hmGitTreeLim :: Monad m => HMGitT m Int

-- | The index file path
hmGitIndexPath :: Monad m => HMGitT m (Path Abs File)

-- | If <tt>refs/heads/master</tt> or <tt>refs/heads/main</tt> exists,
--   return <tt>Right</tt>, if they are not exist, the candidate path is
--   wrapped in <tt>Left</tt> returned.
hmGitBRPath :: MonadIO m => HMGitT m (Either (Path Abs File) (Path Abs File))

-- | Get the path, ignoring whether it is an actual path or a candidate
--   path.
hmGitBRPath' :: MonadIO m => HMGitT m (Path Abs File)

-- | If <tt>refs/heads/master</tt> or <tt>refs/heads/main</tt> exists,
--   return <tt>Right</tt>, if they are not exist, the candidate name is
--   wrapped in <tt>Left</tt> returned.
hmGitBRName :: MonadIO m => HMGitT m (Either String String)

-- | Get the name, ignoring whether it is a real name or a candidate name.
hmGitBRName' :: MonadIO m => HMGitT m String

-- | Returns the current path relative to the hmgit database directory
getCurrentDirFromHMGit :: (MonadThrow m, MonadIO m) => HMGitT m (Path Rel Dir)

-- | HMGit runner
runHMGit :: HMGitT m a -> HMGitConfig -> m a


-- | Matching patterns against file paths akin to the pathspec
--   gitglossary(7) function.
--   
--   <ul>
--   <li><b>NOTE</b>: Currently does not support magic signatures</li>
--   <li>See also:
--   <a>https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefpathspecapathspec</a></li>
--   </ul>
module HMGit.Internal.Parser.Pathspecs

-- | Determines if the path given with <tt>cDir</tt> as the base point
--   matches the pattern, and if so, returns a <tt>FilePath</tt> of
--   relative paths (including <tt>../</tt> etc.) from <tt>cDir</tt>
--   (<tt>P.Path</tt> is not supported <tt>../</tt>, so we must return as a
--   string). If they do not match, some exception will be thrown.
pathspecs :: (MonadCatch m, MonadIO m, Alternative m) => Path Abs Dir -> SomeBase File -> [String] -> HMGitT m FilePath
lsMatches :: (MonadCatch m, MonadIO m) => Path Abs Dir -> [String] -> HMGitT m (Set (Path Abs File))

module HMGit.Internal.Core.Runner

module HMGit.Development
gitCfg :: HMGitConfig

module HMGit.Commands.Porcelain.Init.Core
type RepositoryName = String
newtype Init m
Init :: (RepositoryName -> HMGitT m ()) -> Init m
initDefault :: (MonadThrow m, MonadIO m) => String -> Init m
initQuiet :: MonadIO m => String -> Init m
init :: (String -> Init m) -> String -> RepositoryName -> HMGitT m ()

module HMGit
data HMGitConfig
HMGitConfig :: Path Abs Dir -> Int -> HMGitConfig
[hmGitDir] :: HMGitConfig -> Path Abs Dir
[hmGitTreeLimit] :: HMGitConfig -> Int
HMGitConfigInit :: HMGitConfig
newtype BugException
BugException :: String -> BugException
hmGitConfig :: (MonadThrow m, MonadIO m) => String -> m HMGitConfig
type HMGitT = ReaderT HMGitConfig

-- | HMGit runner
runHMGit :: HMGitT m a -> HMGitConfig -> m a

module HMGit.Internal.Core

-- | The Git object type. Currently, it does not support tags.
data ObjectType

-- | Blob object
Blob :: ObjectType

-- | Commit object
Commit :: ObjectType

-- | Tree object
Tree :: ObjectType

-- | Information for built objects
data ObjectInfo
data IndexEntry
IndexEntry :: Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> Word32 -> ByteString -> Word16 -> Path Rel File -> IndexEntry

-- | the last time a file's metadata changed, this is stat(2) data
[ieCtimeS] :: IndexEntry -> Word32

-- | nanosecond fractions, this is stat(2) data
[ieCtimeN] :: IndexEntry -> Word32

-- | mtime seconds, the last time a file's data changed, this is stat(2)
--   data
[ieMTimeS] :: IndexEntry -> Word32

-- | mtime nanosecond fractions, this is stat(2) data
[ieMTimeN] :: IndexEntry -> Word32

-- | this is stat(2) data
[ieDev] :: IndexEntry -> Word32

-- | this is stat(2) data
[ieIno] :: IndexEntry -> Word32

-- | mode, split into (high to low bits)
[ieMode] :: IndexEntry -> Word32

-- | this is stat(2) data
[ieUid] :: IndexEntry -> Word32

-- | this is stat(2) data
[ieGid] :: IndexEntry -> Word32

-- | This is the on-disk size from stat(2), truncated to 32-bit.
[ieSize] :: IndexEntry -> Word32

-- | 160-bit SHA-1 for the represented object
[ieSha1] :: IndexEntry -> ByteString

-- | A 16-bit <tt>flags</tt> field split into (high to low bits)
[ieFlags] :: IndexEntry -> Word16
[iePath] :: IndexEntry -> Path Rel File

-- | Create object ID, path, zlib compressed data from object type and
--   content
fromContents :: MonadCatch m => ObjectType -> ByteString -> HMGitT m ObjectInfo

-- | Create an object to HMGit database
storeObject :: (MonadIO m, MonadCatch m) => ObjectType -> ByteString -> HMGitT m ByteString

-- | Read an object from HMGit database by Object ID
loadObject :: (MonadIO m, MonadCatch m, MonadPlus m) => String -> HMGitT m (ObjectType, ByteString)

-- | Read a tree from raw data
loadTree :: MonadThrow m => ByteString -> HMGitT m [(CMode, Path Rel File, String)]

-- | Create a tree object to HMGit database <b>NOTE</b>: Currently only
--   supports a single, top-level directory
storeTree :: (MonadIO m, MonadCatch m) => HMGitT m ByteString

-- | Read index entries
loadIndex :: (MonadIO m, MonadThrow m) => HMGitT m [IndexEntry]

-- | Write index entries
storeIndex :: (MonadIO m, Foldable t) => t IndexEntry -> HMGitT m ()

-- | Data representing status
data HMGitStatus

-- | Calculates the latest, or current, hash of the working tree and
--   returns a map of its path and hash value.
--   
--   <b>NOTE</b>: Currently <a>latestBlobHashes</a> does not support
--   gitignore and submodule, so we are embedding content to ignore
--   directly in the code. Comments HACK below are the relevant part.
latestBlobHashes :: (MonadIO m, MonadCatch m) => HMGitT m (Map (Path Rel File) String)

-- | Returns a map of blob file paths and hashes that are already part of
--   the repository. This is a pair with <a>latestBlobHashes</a>.
indexedBlobHashes :: (MonadIO m, MonadCatch m) => HMGitT m (Map (Path Rel File) String)

-- | Get status
getStatus :: (MonadIO m, MonadCatch m) => HMGitT m HMGitStatus
instance GHC.Show.Show HMGit.Internal.Core.HMGitStatus

module HMGit.Commands.Porcelain.Status.Core
newtype Status m
Status :: (StatusCfg -> HMGitT m ()) -> Status m
[status] :: Status m -> StatusCfg -> HMGitT m ()
newtype StatusCfg
StatusCfg :: [String] -> StatusCfg
[statusPathspecs] :: StatusCfg -> [String]
statusDefault :: (MonadIO m, MonadCatch m, Alternative m) => Status m
statusShort :: (MonadCatch m, MonadIO m, Alternative m) => Status m

module HMGit.Commands.Porcelain.Diff.Core
type ShowDiff = FilePath " file name" -> String " first contents" -> String " second contents" -> String
newtype Diff m
Diff :: (DiffCfg -> HMGitT m ()) -> Diff m
[diff] :: Diff m -> DiffCfg -> HMGitT m ()
data DiffCfg
DiffCfg :: ShowDiff -> [FilePath] -> DiffCfg
[diffShow] :: DiffCfg -> ShowDiff
[diffPath] :: DiffCfg -> [FilePath]
showDiff :: String -> String -> ShowDiff
diffDefault :: (MonadIO m, MonadCatch m, MonadPlus m) => Diff m

module HMGit.Commands.Porcelain.Add.Core
newtype Add m
Add :: (AddCfg -> HMGitT m ()) -> Add m
[add] :: Add m -> AddCfg -> HMGitT m ()
newtype AddCfg
AddCfg :: [FilePath] -> AddCfg
[addPathspecs] :: AddCfg -> [FilePath]
addDefault :: (MonadIO m, MonadCatch m) => Add m
addDryRun :: (MonadCatch m, MonadIO m) => Add m

module HMGit.Commands.Plumbing.CatFile.Core
data CatFile m
CatFileObjectType :: ObjectType -> (ObjectType -> ByteString -> HMGitT m ()) -> CatFile m
CatFileMode :: (ObjectType -> ByteString -> HMGitT m ()) -> CatFile m
catOptObject :: MonadIO m => ObjectType -> CatFile m
catOptObjectType :: MonadIO m => CatFile m
catOptObjectSize :: MonadIO m => CatFile m
catOptObjectPP :: (MonadIO m, MonadThrow m) => CatFile m
catFile :: (MonadIO m, MonadCatch m, MonadPlus m) => CatFile m -> String -> HMGitT m ()
instance Control.Monad.IO.Class.MonadIO m => Data.String.IsString (HMGit.Commands.Plumbing.CatFile.Core.CatFile m)

module HMGit.Commands.Porcelain.Commit.Core
newtype Commit m
Commit :: (CommitCfg -> HMGitT m ()) -> Commit m
[commit] :: Commit m -> CommitCfg -> HMGitT m ()
data CommitCfg
CommitCfg :: String -> String -> CommitCfg
[commitMessage] :: CommitCfg -> String
[commitAuthor] :: CommitCfg -> String
commitDefault :: (MonadIO m, MonadCatch m) => Commit m
instance GHC.Show.Show HMGit.Commands.Porcelain.Commit.Core.CommitCfg

module HMGit.Commands.Plumbing.LsFiles.Core
newtype LsFiles m
LsFiles :: (LsFilesCfg -> HMGitT m ()) -> LsFiles m
[lsFiles] :: LsFiles m -> LsFilesCfg -> HMGitT m ()
newtype LsFilesCfg
LsFilesCfg :: [String] -> LsFilesCfg
[lsFilesPathspecs] :: LsFilesCfg -> [String]
lsFilesShow :: (MonadCatch m, MonadIO m, Alternative m) => LsFiles m
lsFilesDetail :: (MonadCatch m, MonadIO m, Alternative m) => LsFiles m

module HMGit.Commands.Plumbing.HashObject.Core
newtype HashObject m
HashObject :: (ObjectType -> ByteString -> HMGitT m ()) -> HashObject m
hashObjectShow :: (MonadCatch m, MonadIO m) => HashObject m
hashObjectWrite :: (MonadCatch m, MonadIO m) => HashObject m
hashObject :: (MonadCatch m, MonadIO m) => HashObject m -> ObjectType -> FilePath -> HMGitT m ()

module HMGit.Commands

-- | Commands supported by HMGit
data Cmd m

-- | init
CmdInit :: (String -> Init m) -> RepositoryName -> Cmd m

-- | add
CmdAdd :: Add m -> AddCfg -> Cmd m

-- | cat-file
CmdCatFile :: CatFile m -> String -> Cmd m

-- | hash-object
CmdHashObject :: ObjectType -> HashObject m -> FilePath -> Cmd m

-- | ls-files
CmdLsFiles :: LsFiles m -> LsFilesCfg -> Cmd m

-- | status
CmdStatus :: Status m -> StatusCfg -> Cmd m

-- | diff
CmdDiff :: Diff m -> DiffCfg -> Cmd m

-- | commit
CmdCommit :: Commit m -> CommitCfg -> Cmd m

module HMGit.Commands.Porcelain.Status.Cmd
statusCmd :: (MonadCatch m, MonadIO m, Alternative m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Porcelain.Status
newtype Status m
Status :: (StatusCfg -> HMGitT m ()) -> Status m
[status] :: Status m -> StatusCfg -> HMGitT m ()
statusCmd :: (MonadCatch m, MonadIO m, Alternative m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Porcelain.Init.Cmd
initCmd :: (MonadThrow m, MonadIO m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Porcelain.Init
init :: (String -> Init m) -> String -> RepositoryName -> HMGitT m ()
newtype Init m
Init :: (RepositoryName -> HMGitT m ()) -> Init m
initCmd :: (MonadThrow m, MonadIO m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Porcelain.Diff.Cmd
diffCmd :: (MonadCatch m, MonadIO m, MonadPlus m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Porcelain.Diff
newtype Diff m
Diff :: (DiffCfg -> HMGitT m ()) -> Diff m
[diff] :: Diff m -> DiffCfg -> HMGitT m ()
diffCmd :: (MonadCatch m, MonadIO m, MonadPlus m) => Mod CommandFields (Cmd m)
showDiff :: String -> String -> ShowDiff

module HMGit.Commands.Porcelain.Commit.Cmd

-- | The commit command field
commitCmd :: (MonadIO m, MonadCatch m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Porcelain.Commit
newtype Commit m
Commit :: (CommitCfg -> HMGitT m ()) -> Commit m
[commit] :: Commit m -> CommitCfg -> HMGitT m ()
data CommitCfg
CommitCfg :: String -> String -> CommitCfg
[commitMessage] :: CommitCfg -> String
[commitAuthor] :: CommitCfg -> String

-- | The commit command field
commitCmd :: (MonadIO m, MonadCatch m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Porcelain.Add.Cmd
addCmd :: (MonadCatch m, MonadIO m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Porcelain.Add
newtype Add m
Add :: (AddCfg -> HMGitT m ()) -> Add m
[add] :: Add m -> AddCfg -> HMGitT m ()
addCmd :: (MonadCatch m, MonadIO m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Plumbing.LsFiles.Cmd
lsFilesCmd :: (MonadCatch m, MonadIO m, Alternative m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Plumbing.LsFiles
newtype LsFiles m
LsFiles :: (LsFilesCfg -> HMGitT m ()) -> LsFiles m
[lsFiles] :: LsFiles m -> LsFilesCfg -> HMGitT m ()
lsFilesCmd :: (MonadCatch m, MonadIO m, Alternative m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Plumbing.HashObject.Cmd
hashObjectCmd :: (MonadCatch m, MonadIO m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Plumbing.HashObject
hashObject :: (MonadCatch m, MonadIO m) => HashObject m -> ObjectType -> FilePath -> HMGitT m ()
newtype HashObject m
HashObject :: (ObjectType -> ByteString -> HMGitT m ()) -> HashObject m
hashObjectCmd :: (MonadCatch m, MonadIO m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Plumbing.CatFile.Cmd
catFileCmd :: (MonadThrow m, MonadIO m) => Mod CommandFields (Cmd m)

module HMGit.Commands.Plumbing.CatFile
catFile :: (MonadIO m, MonadCatch m, MonadPlus m) => CatFile m -> String -> HMGitT m ()
data CatFile m
CatFileObjectType :: ObjectType -> (ObjectType -> ByteString -> HMGitT m ()) -> CatFile m
CatFileMode :: (ObjectType -> ByteString -> HMGitT m ()) -> CatFile m
catFileCmd :: (MonadThrow m, MonadIO m) => Mod CommandFields (Cmd m)
